<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoIntel - Satellite Intelligence Platform</title>

    <!-- Google Fonts - Roboto -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(32, 33, 36, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 14px;
            z-index: 2000;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Tools FAB */
        .tools-fab {
            position: absolute;
            right: 16px;
            top: 80px;
            background: white;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            z-index: 100;
            border: none;
            transition: transform 0.2s;
        }

        .tools-fab:hover {
            transform: scale(1.05);
        }

        .tools-menu {
            position: absolute;
            right: 70px;
            top: 80px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            padding: 8px 0;
            display: none;
            z-index: 100;
            width: 160px;
        }

        .tools-menu.show {
            display: block;
        }

        .tool-item {
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: #3C4043;
        }

        .ai-prediction-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: linear-gradient(135deg, #6200ea, #b388ff);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 700;
            margin-left: 8px;
            box-shadow: 0 2px 4px rgba(98, 0, 234, 0.2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0% {
                box-shadow: 0 0 0 0 rgba(179, 136, 255, 0.4);
            }

            70% {
                box-shadow: 0 0 0 6px rgba(179, 136, 255, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(179, 136, 255, 0);
            }
        }

        .tool-item:hover {
            background: #F1F3F4;
        }
    </style>

    <!-- Google Maps API -->
    <script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBp7r2D1nmfSnKysVgJjLOpeEQ7KAQkp2E&libraries=places,drawing,visualization,geometry"></script>

    <!-- Google Earth Engine API -->
    <script src="https://earthengine.googleapis.com/v1/earthengine_api.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #FFFFFF;
            color: #202124;
            overflow: hidden;
        }

        /* Header */
        .header {
            height: 60px;
            background: rgba(255, 255, 255, 0.7);
            /* More transparent */
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            z-index: 1001;
            position: absolute;
            /* Overlay on map */
            top: 0;
            left: 0;
            right: 0;
        }

        .logo {
            font-size: 20px;
            font-weight: 500;
            color: #5F6368;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-icon {
            color: #1A73E8;
        }

        .status-indicator {
            margin-left: auto;
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-indicator.connected {
            background: #E6F4EA;
            color: #137333;
        }

        .status-indicator.disconnected {
            background: #FCE8E6;
            color: #C5221F;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }

        /* Search Bar */
        .search-container {
            position: absolute;
            top: 76px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: 90%;
            max-width: 600px;
        }

        .search-box {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 24px;
            padding: 10px 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .search-box:hover {
            box-shadow: 0 2px 8px rgba(32, 33, 36, 0.28);
        }

        .search-box:focus-within {
            box-shadow: 0 4px 12px rgba(32, 33, 36, 0.28);
            border-color: #1A73E8;
        }

        .search-input {
            flex: 1;
            border: none;
            background: transparent;
            color: #202124;
            font-size: 14px;
            outline: none;
            padding: 0 12px;
            font-family: 'Roboto', sans-serif;
        }

        .search-input::placeholder {
            color: #5F6368;
        }

        .icon-button {
            background: none;
            border: none;
            color: #5F6368;
            cursor: pointer;
            padding: 6px;
            border-radius: 50%;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-button:hover {
            background: #F1F3F4;
        }

        .icon-button.primary {
            color: #1A73E8;
        }

        .icon-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .material-icons {
            font-size: 20px;
        }

        /* Map */
        #map {
            width: 100%;
            height: 100vh;
            /* Full screen */
        }

        /* Analysis Controls */
        .analysis-controls {
            position: absolute;
            top: 80px;
            /* Moved up since header is overlay */
            left: 16px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 12px;
            max-width: 200px;
        }

        .control-title {
            font-size: 13px;
            font-weight: 500;
            color: #202124;
            margin-bottom: 12px;
        }

        .control-option {
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            color: #5F6368;
            transition: background-color 0.2s;
            margin-bottom: 4px;
        }

        .control-option:hover {
            background: #F1F3F4;
        }

        .control-option.active {
            background: #E8F0FE;
            color: #1A73E8;
        }

        /* Map Type Controls */
        .map-controls {
            position: absolute;
            bottom: 120px;
            right: 16px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: #FFFFFF;
            border: none;
            border-radius: 2px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .control-button:hover {
            background: #F8F9FA;
        }

        .control-button.active {
            background: #E8F0FE;
        }

        .control-button .material-icons {
            color: #5F6368;
            font-size: 20px;
        }

        .control-button.active .material-icons {
            color: #1A73E8;
        }

        /* Results Panel */
        .results-panel {
            position: absolute;
            right: -380px;
            top: 60px;
            width: 380px;
            height: calc(100vh - 60px);
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255, 255, 255, 0.3);
            overflow-y: auto;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 999;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.1);
        }

        .results-panel.open {
            right: 0;
        }

        .results-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.5);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .results-title {
            font-size: 18px;
            font-weight: 500;
            color: #202124;
        }

        .results-content {
            padding: 20px;
        }

        .result-card {
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            transition: transform 0.2s;
        }

        .result-card:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.8);
        }

        .card-title {
            font-size: 11px;
            font-weight: 500;
            color: #5F6368;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .card-value {
            font-size: 16px;
            font-weight: 400;
            color: #202124;
        }

        .metric-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .metric-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }

        .metric-content {
            flex: 1;
        }

        .metric-label {
            font-size: 13px;
            color: #5F6368;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 400;
            color: #202124;
        }

        .progress-bar {
            height: 4px;
            background: #E8EAED;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: #1A73E8;
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 8px;
        }

        .badge.positive {
            background: #E6F4EA;
            color: #137333;
        }

        .badge.negative {
            background: #FCE8E6;
            color: #C5221F;
        }

        .badge.neutral {
            background: #FEF7E0;
            color: #F29900;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 300px;
            /* Increased height to ensure visible separation from map type controls */
            right: 16px;
            z-index: 100;
            background: #FFFFFF;
            border-radius: 2px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .zoom-button {
            width: 40px;
            height: 40px;
            background: #FFFFFF;
            border: none;
            border-bottom: 1px solid #E8EAED;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .zoom-button:last-child {
            border-bottom: none;
        }

        .zoom-button:hover {
            background: #F8F9FA;
        }

        .zoom-button .material-icons {
            color: #5F6368;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            flex-direction: column;
            gap: 16px;
        }

        .loading-overlay.show {
            display: flex;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #E8EAED;
            border-top-color: #1A73E8;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: #5F6368;
            font-size: 14px;
        }

        /* Mobile Responsiveness */
        @media (max-width: 600px) {
            .results-panel {
                width: 100%;
                right: -100%;
                top: 0;
                height: 100vh;
                z-index: 2000;
                /* On top of everything */
            }

            .results-panel.open {
                right: 0;
            }

            .search-container {
                top: 16px;
                width: 95%;
            }

            .analysis-controls {
                top: 80px;
                left: 10px;
            }

            .map-controls {
                bottom: 80px;
            }

            .zoom-controls {
                bottom: 180px;
            }

        }

        /* Dashboard Sheet Styles (Places UI Kit inspired) */
        .dashboard-sheet {
            position: absolute;
            top: 76px;
            left: 16px;
            width: 360px;
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            max-height: calc(100vh - 100px);
            font-family: 'Google Sans', 'Roboto', sans-serif;
        }

        .sheet-header {
            padding: 16px 20px;
            border-bottom: 1px solid #F1F3F4;
            background: #fff;
        }

        .sheet-title {
            font-size: 18px;
            font-weight: 500;
            color: #202124;
        }

        .sheet-subtitle {
            font-size: 12px;
            color: #5F6368;
            margin-top: 4px;
        }

        /* Indicators Carousel */
        .indicators-carousel {
            display: flex;
            overflow-x: auto;
            padding: 16px 16px;
            gap: 12px;
            scrollbar-width: none;
            /* Hide scrollbar */
        }

        .indicators-carousel::-webkit-scrollbar {
            display: none;
        }

        .indicator-card {
            min-width: 100px;
            padding: 12px;
            border-radius: 12px;
            border: 1px solid #E8EAED;
            background: #FFFFFF;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .indicator-card:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .indicator-card.active {
            border-color: #1A73E8;
            background: #F8F9FA;
            box-shadow: 0 2px 8px rgba(26, 115, 232, 0.2);
        }

        .indicator-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }

        .indicator-icon.negative {
            background: #FCE8E6;
            color: #C5221F;
        }

        .indicator-icon.warning {
            background: #FEF7E0;
            color: #F29900;
        }

        .indicator-icon.neutral {
            background: #E6F4EA;
            color: #137333;
        }

        .indicator-label {
            font-size: 11px;
            font-weight: 500;
            color: #5F6368;
        }

        .indicator-value {
            font-size: 14px;
            font-weight: 500;
            color: #202124;
            margin-top: 2px;
        }

        /* Insight Panel */
        .insight-panel {
            padding: 0 20px 20px 20px;
        }

        .insight-headline {
            font-size: 16px;
            font-weight: 500;
            color: #202124;
            margin-bottom: 8px;
        }

        .insight-text {
            font-size: 14px;
            color: #3C4043;
            line-height: 1.5;
            margin-bottom: 16px;
        }

        .section-label {
            font-size: 10px;
            letter-spacing: 1px;
            color: #5F6368;
            font-weight: 500;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .action-card {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #F8F9FA;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 4px solid #1A73E8;
        }

        .action-icon {
            color: #1A73E8;
            margin-right: 12px;
            font-size: 20px;
        }

        .action-card span {
            font-size: 13px;
            color: #3C4043;
        }

        /* Advanced Layers */
        .advanced-layers {
            border-top: 1px solid #F1F3F4;
            padding: 0;
        }

        .advanced-header {
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
            color: #5F6368;
            font-weight: 500;
        }

        .layer-list {
            padding: 0 20px 16px 20px;
        }
    </style>
</head>

<body>
    <!-- Header -->
    <div class="header"><span class="material-icons logo-icon" style="font-size: 24px;">satellite</span>
        <div class="logo">GeoIntel</div>
        <div class="status-indicator disconnected" id="statusIndicator"><span class="status-dot"></span><span
                id="statusText">Connecting to Earth Engine...</span></div>
    </div>
    <!-- Search Bar -->
    <div class="search-container">
        <div class="search-box"><span class="material-icons" style="cursor: pointer;"
                onclick="analyzeLocation()">search</span><input type="text" class="search-input" id="searchInput"
                placeholder="Search location or ask (e.g. 'Show water in Kenya')"><button class="icon-button"
                onclick="getCurrentLocation()"><span class="material-icons">my_location</span></button></div>
    </div>
    <!-- Kenya Decision Dashboard -->
    <div class="dashboard-sheet">
        <div class="sheet-header">
            <div class="sheet-title" id="sheetTitle">Global EO Intelligence</div>
            <div class="sheet-subtitle" id="sheetSubtitle">Regional Decision Support</div>
        </div>
        <!-- Smart Indicators Carousel -->
        <div class="indicators-carousel">
            <div class="indicator-card active" onclick="activateDashboardMode('drought')">
                <div class="indicator-icon negative"><span class="material-icons">sentiment_very_dissatisfied</span>
                </div>
                <div class="indicator-label">Drought Risk</div>
                <div class="indicator-value" id="droughtValue">High</div>
            </div>
            <div class="indicator-card" onclick="activateDashboardMode('vegetation')">
                <div class="indicator-icon warning"><span class="material-icons">grass</span></div>
                <div class="indicator-label">Crop Health</div>
                <div class="indicator-value" id="cropValue">-12%</div>
            </div>
            <div class="indicator-card" onclick="activateDashboardMode('flood')">
                <div class="indicator-icon neutral"><span class="material-icons">water</span></div>
                <div class="indicator-label">Flood Risk</div>
                <div class="indicator-value" id="floodValue">Normal</div>
            </div>
            <div class="indicator-card" onclick="activateDashboardMode('urban')">
                <div class="indicator-icon neutral"><span class="material-icons">location_city</span>
                </div>
                <div class="indicator-label">Urban Growth</div>
                <div class="indicator-value" id="urbanValue">+2.5%</div>
            </div>
        </div>
        <!-- Dynamic Insight Panel -->
        <div class="insight-panel" id="insightPanel">
            <div class="insight-headline" id="insightHeadline">Drought stress detected in Northern
                Counties</div>
            <div class="insight-date" id="insightDate"
                style="color: #202124; font-size: 16px; font-weight: 500; margin-bottom: 12px; display: flex; align-items: center; gap: 6px;">
                <input type="date" id="insightDateInput"
                    style="border: 1px solid #dadce0; border-radius: 4px; padding: 4px 8px; background: #fff; color: #1a73e8; font-family: inherit; font-size: inherit; font-weight: inherit; cursor: pointer;">
            </div>
            <div class="insight-text" id="insightText">Vegetation index (NDVI) has dropped below the
                5-year average. Long rains have likely failed in this region. </div>
            <div class="action-section">
                <div class="section-label">RECOMMENDED ACTIONS</div>
                <div class="action-card" id="actionCard1"><span
                        class="material-icons action-icon">water_drop</span><span id="actionText1">Activate drought
                        contingency fund</span></div>
                <div class="action-card" id="actionCard2"><span
                        class="material-icons action-icon">agriculture</span><span id="actionText2">Distribute
                        drought-resistant seeds</span></div>
            </div>
        </div>
        <!-- Advanced Data Layers (Accordion) -->
        <div class="advanced-layers">
            <div class="advanced-header" onclick="toggleAdvancedLayers()"><span>Satellite Data
                    Sources</span><span class="material-icons" id="advancedIcon">expand_more</span></div>
            <div class="layer-list" id="layerList" style="display:none;">
                <div class="control-option" onclick="setAnalysisType('vegetation')">Sentinel-2
                    (Vegetation)</div>
                <div class="control-option" onclick="setAnalysisType('water')">Sentinel-1
                    (Water/Flood)</div>
                <div class="control-option" onclick="toggleTemporalMode()">Landsat 8/9 (Time
                    Series)</div>
                <div class="control-option" onclick="setAnalysisType('temperature')">MODIS
                    (Temperature)</div>
            </div>
        </div>
    </div>
    <!-- Map -->
    <div id="map"></div>
    <!-- Zoom Controls -->
    <div class="zoom-controls"><button class="zoom-button" onclick="map.setZoom(map.getZoom() + 1)"><span
                class="material-icons">add</span></button><button class="zoom-button"
            onclick="map.setZoom(map.getZoom() - 1)"><span class="material-icons">remove</span></button></div>
    <!-- Map Type Controls -->
    <div class="map-controls"><button class="control-button active" onclick="setMapType('roadmap')"
            title="Default"><span class="material-icons">map</span></button><button class="control-button"
            onclick="setMapType('satellite')" title="Satellite"><span
                class="material-icons">satellite</span></button><button class="control-button"
            onclick="setMapType('terrain')" title="Terrain"><span class="material-icons">terrain</span></button></div>
    <!-- Results Panel -->
    <div class="results-panel" id="resultsPanel">
        <div class="results-header">
            <div class="results-title">Satellite Analysis</div><button class="icon-button"
                onclick="closeResults()"><span class="material-icons">close</span></button>
        </div>
        <div class="results-content" id="resultsContent"></div>
    </div>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Analyzing satellite imagery...</div>
    </div>
    <!-- Tools FAB --><button class="tools-fab" onclick="toggleToolsMenu()" title="Geospatial Tools"><span
            class="material-icons" style="color: #5F6368;">straighten</span></button>
    <div class="tools-menu" id="toolsMenu">
        <div class="tool-item" onclick="startMeasurement('distance')"><span
                class="material-icons">timeline</span>Measure Distance </div>
        <div class="tool-item" onclick="startMeasurement('area')"><span class="material-icons">crop_square</span>Measure
            Area </div>
        <div class="tool-item" onclick="clearMeasurements()"><span class="material-icons">delete</span>Clear All </div>
    </div>
    <!-- Toast Notification -->
    <div id="toast" class="toast"><span class="material-icons">info</span><span id="toastMessage">Notification</span>
    </div>
    <script>let map;
        let geocoder;
        let currentAnalysisType = 'vegetation';
        let eeInitialized = false;
        let currentMarker = null;
        let loadingTimeout = null;
        let drawingManager = null;
        let currentShape = null;
        let temporalMode = true;
        let lastAnalysisData = null;

        // --- Kenya Dashboard Logic ---
        const DASHBOARD_DATA = {
            'drought': {

                headline: "Drought stress detected in Northern Counties",
                text: "Vegetation index (NDVI) has dropped below the 5-year average. Long rains have likely failed in this region.",
                actions: [{
                    icon: 'water_drop', text: "Activate drought contingency fund"
                }

                    ,
                {
                    icon: 'agriculture', text: "Distribute drought-resistant seeds"
                }

                ],
                layer: 'vegetation'
            }

            ,
            'vegetation': {

                headline: "Crop Health Alert: Maize Yield Risk",
                text: "Satellite imagery shows significant yellowing in maize belts. Potential pest infestation or moisture stress.",
                actions: [{
                    icon: 'bug_report', text: "Deploy field officers for pest inspection"
                }

                    ,
                {
                    icon: 'timeline', text: "Review fertilizer subsidies"
                }

                ],
                layer: 'vegetation'
            }

            ,
            'flood': {

                headline: "Flood Watch: Riverine Zones",
                text: "Soil moisture saturation has reached 90%. Heavy rains predicted upstream will likely cause overflow.",
                actions: [{
                    icon: 'warning', text: "Issue evacuation alerts for floodplains"
                }

                    ,
                {
                    icon: 'cleaning_services', text: "Clear urban drainage channels"
                }

                ],
                layer: 'water'
            }

            ,
            'urban': {

                headline: "Urban Expansion Rate Increasing",
                text: "Informal settlements in perimeter zones have grown by 2.5% this quarter, stressing water infrastructure.",
                actions: [{
                    icon: 'engineering', text: "Plan new water connection points"
                }

                    ,
                {
                    icon: 'map', text: "Update zoning maps"
                }

                ],
                layer: 'urban'
            }
        }

            ;

        let currentDashboardMode = 'drought'; // Default

        function activateDashboardMode(mode) {
            currentDashboardMode = mode;

            // 1. Update UI Active State
            const card = event.target.closest('.indicator-card');
            if (card) {
                document.querySelectorAll('.indicator-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
            }

            // 2. Trigger Analysis Layer Update
            // This will trigger performSatelliteAnalysis -> showResults -> updateDashboardState
            // We find the layer from the mode mapping
            const layerMap = {
                'drought': 'vegetation',
                'vegetation': 'vegetation', // Crop Health
                'flood': 'water',
                'urban': 'urban'
            };

            setAnalysisType(layerMap[mode] || 'vegetation');
        }

        function toggleAdvancedLayers() {
            const list = document.getElementById('layerList');
            const icon = document.getElementById('advancedIcon');

            if (list.style.display === 'none') {
                list.style.display = 'block';
                icon.innerText = 'expand_less';
            }

            else {
                list.style.display = 'none';
                icon.innerText = 'expand_more';
            }
        }

        // Helper to update the left Dashboard panel based on real analysis data
        function updateDashboardState(locationName, analysis) {
            // Logic to determine "Risk" based on simulated values
            const isDrought = analysis.ndvi < 0.45;
            const isFlood = analysis.ndwi > 0.45;
            const isUrban = analysis.ndbi > 0.4;

            // Update Sheet Title
            const titleEl = document.getElementById('sheetTitle');
            if (titleEl) {
                // If locationName is very long, truncate or just use "Local"
                if (locationName.length > 25) {
                    titleEl.innerText = "Local EO Intelligence";
                } else {
                    titleEl.innerText = `${locationName} EO Intelligence`;
                }
            }

            // Determine context based on currentDashboardMode (set by user click)
            // If undefined (initial load), default to 'drought'
            const mode = currentDashboardMode || 'drought';

            // Set Date Input
            const dateInput = document.getElementById('insightDateInput');
            if (dateInput && analysis.date) {
                dateInput.value = analysis.date;

                // Add listener if not already there (simple check)
                if (!dateInput.dataset.listenerAdded) {
                    dateInput.addEventListener('change', (e) => {
                        const newDate = e.target.value;
                        if (lastAnalysisData && newDate) {
                            performSatelliteAnalysis(
                                lastAnalysisData.location,
                                lastAnalysisData.bounds,
                                lastAnalysisData.placeName,
                                lastAnalysisData.geocodeResult,
                                newDate
                            );
                        }
                    });
                    dateInput.dataset.listenerAdded = "true";
                }
            }

            // Check for Future Date (AI Prediction Mode)
            const analysisDateObj = new Date(analysis.date);
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize today
            // We consider it "future" if it's strictly greater than today (tomorrow onwards)
            // Adding a small buffer to handle timezone weirdness if needed, but simple comparison works
            const isFuture = analysisDateObj > today;

            const badgeHTML = isFuture ? '<span class="ai-prediction-badge"><span class="material-icons" style="font-size: 11px;">auto_awesome</span>AI Prediction</span>' : '';
            const prefix = isFuture ? 'Predicted: ' : '';

            let headline = "";
            let text = "";
            let actions = [];

            if (mode === 'drought') {
                if (isDrought || analysis.ndvi < 0.5) {
                    headline = `${prefix}Drought Warning: ${locationName} ${badgeHTML}`;
                    text = isFuture
                        ? `AI models foreacst vegetation index (NDVI ${analysis.ndvi.toFixed(2)}) to drop below critical levels.`
                        : `Vegetation index (${analysis.ndvi.toFixed(2)}) is low. Immediate intervention required.`;
                    actions = [{ icon: 'water_drop', text: "Deploy water tankers" }, { icon: 'savings', text: "Activate emergency funds" }];
                } else {
                    headline = `${prefix}Drought Risk Low: ${locationName} ${badgeHTML}`;
                    text = isFuture
                        ? `Vegetation is predicted to remain healthy (${analysis.ndvi.toFixed(2)}).`
                        : `Vegetation is healthy (${analysis.ndvi.toFixed(2)}). No immediate drought signs.`;
                    actions = [{ icon: 'check_circle', text: "Continue monitoring" }, { icon: 'inventory', text: "Stockpile reserves" }];
                }
            }
            else if (mode === 'vegetation') { // Crop Health
                if (analysis.ndvi < 0.5) {
                    headline = `${prefix}Crop Health Alert: ${locationName} ${badgeHTML}`;
                    text = isFuture
                        ? `Forecast suggests vegetation stress. Yields predicted to be impacted.`
                        : `Vegetation stress detected. Potential pest or moisture issues affecting yields.`;
                    actions = [{ icon: 'bug_report', text: "Inspect for pests" }, { icon: 'analytics', text: "Analyze soil moisture" }];
                } else {
                    headline = `${prefix}Crop Conditions Favorable ${badgeHTML}`;
                    text = isFuture
                        ? `Models predict healthy crop development (${analysis.ndvi.toFixed(2)}).`
                        : `Vegetation index (${analysis.ndvi.toFixed(2)}) indicates healthy crop development.`;
                    actions = [{ icon: 'store', text: "Prepare storage units" }, { icon: 'local_shipping', text: "Plan harvest logistics" }];
                }
            }
            else if (mode === 'flood') {
                if (isFlood || analysis.ndwi > 0.4) {
                    headline = `${prefix}Flood Risk Elevated: ${locationName} ${badgeHTML}`;
                    text = isFuture
                        ? `Prediction indicates saturation (${analysis.ndwi.toFixed(2)}). Localized flooding expected.`
                        : `Water index (${analysis.ndwi.toFixed(2)}) indicates saturation. Potential for localized flooding.`;
                    actions = [{ icon: 'warning', text: "Issue alert to residents" }, { icon: 'cleaning_services', text: "Check drainage systems" }];
                } else {
                    headline = `${prefix}Flood Risk Normal ${badgeHTML}`;
                    text = isFuture
                        ? `Water levels predicted to stay within safe limits (${analysis.ndwi.toFixed(2)}).`
                        : `Water levels (${analysis.ndwi.toFixed(2)}) are within safe limits.`;
                    actions = [{ icon: 'monitor', text: "Monitor river gauges" }, { icon: 'build', text: "Maintain levees" }];
                }
            }
            else if (mode === 'urban') {
                if (isUrban) {
                    headline = `${prefix}Urban Density High: ${locationName} ${badgeHTML}`;
                    text = isFuture
                        ? `Urban expansion projected to continue rapidly (${analysis.ndbi.toFixed(2)}).`
                        : `Built-up index (${analysis.ndbi.toFixed(2)}) shows rapid expansion. Infrastructure stress likely.`;
                    actions = [{ icon: 'traffic', text: "Review traffic patterns" }, { icon: 'location_city', text: "Audit zoning compliance" }];
                } else {
                    headline = `${prefix}Urban Density Moderate ${badgeHTML}`;
                    text = isFuture
                        ? `Growth predicted to follow planned trajectory (${analysis.ndbi.toFixed(2)}).`
                        : `Built-up index (${analysis.ndbi.toFixed(2)}) is consistent with planned growth.`;
                    actions = [{ icon: 'map', text: "Update city maps" }, { icon: 'park', text: "Plan green spaces" }];
                }
            }

            // Apply to UI
            const headlineEl = document.getElementById('insightHeadline');
            const textEl = document.getElementById('insightText');

            if (headlineEl) headlineEl.innerHTML = headline; // Use innerHTML for badge
            if (textEl) textEl.innerText = text;

            const a1 = document.getElementById('actionCard1');
            const a2 = document.getElementById('actionCard2');
            if (a1) {
                a1.querySelector('.action-icon').innerText = actions[0].icon;
                document.getElementById('actionText1').innerText = actions[0].text;
            }
            if (a2) {
                a2.querySelector('.action-icon').innerText = actions[1].icon;
                document.getElementById('actionText2').innerText = actions[1].text;
            }

            // Update Cards 
            // 1. Drought Risk (Based on NDVI)
            const droughtVal = document.getElementById('droughtValue');
            if (droughtVal) {
                if (analysis.ndvi < 0.35) { droughtVal.innerText = 'Severe'; droughtVal.style.color = '#C5221F'; }
                else if (analysis.ndvi < 0.5) { droughtVal.innerText = 'High'; droughtVal.style.color = '#D93025'; }
                else { droughtVal.innerText = 'Low'; droughtVal.style.color = '#188038'; }
            }

            // 2. Crop Health (NDVI Change Simulation)
            const cropVal = document.getElementById('cropValue');
            if (cropVal) {
                const diff = (analysis.ndvi - 0.6) * 100; // variance from ideal 0.6
                const sign = diff > 0 ? '+' : '';
                cropVal.innerText = `${sign}${diff.toFixed(0)}%`;
                cropVal.style.color = diff < -10 ? '#D93025' : (diff > 0 ? '#188038' : '#F29900');
            }

            // 3. Flood Risk (Based on NDWI)
            const floodVal = document.getElementById('floodValue');
            if (floodVal) {
                if (analysis.ndwi > 0.5) { floodVal.innerText = 'Critical'; floodVal.style.color = '#C5221F'; }
                else if (analysis.ndwi > 0.4) { floodVal.innerText = 'High'; floodVal.style.color = '#F29900'; }
                else { floodVal.innerText = 'Normal'; floodVal.style.color = '#188038'; }
            }

            // 4. Urban Growth (Based on NDBI)
            const urbanVal = document.getElementById('urbanValue');
            if (urbanVal) {
                const growth = (analysis.ndbi * 5).toFixed(1); // Fake logic
                urbanVal.innerText = `+${growth}%`;
            }
        }

        // Initialize Google Maps and Earth Engine
        async function initMap() {
            try {

                // Initialize Google Maps
                map = new google.maps.Map(document.getElementById('map'), {
                    center: {
                        lat: 0, lng: 0
                    }

                    ,
                    zoom: 3,
                    disableDefaultUI: false,
                    zoomControl: false,
                    mapTypeControl: false,
                    scaleControl: true,
                    streetViewControl: false,
                    rotateControl: false,
                    fullscreenControl: true,
                    gestureHandling: 'greedy'
                });

                geocoder = new google.maps.Geocoder();

                // Initialize Drawing Manager
                drawingManager = new google.maps.drawing.DrawingManager({

                    drawingMode: null,
                    drawingControl: false,
                    polygonOptions: {
                        fillColor: '#1A73E8',
                        fillOpacity: 0.3,
                        strokeWeight: 2,
                        clickable: true,
                        editable: true,
                        zIndex: 1
                    }

                    ,
                    polylineOptions: {
                        strokeColor: '#C5221F',
                        strokeWeight: 3
                    }
                });
                drawingManager.setMap(map);

                // Listen for measurement completion
                google.maps.event.addListener(drawingManager, 'overlaycomplete', function (event) {
                    drawingManager.setDrawingMode(null); // Stop drawing
                    calculateMeasurement(event);
                });

                // Initialize Autocomplete - REMOVED per user request
                // const input = document.getElementById('searchInput');
                // const autocomplete = new google.maps.places.Autocomplete(input);
                // autocomplete.bindTo('bounds', map);

                const input = document.getElementById('searchInput');

                // Enter Key Listener
                input.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        analyzeLocation();
                    }
                });

                // Listen for place selection - REMOVED
                // autocomplete.addListener('place_changed', () => { ... });

                // Check for Maps API errors
                google.maps.event.addListenerOnce(map, 'idle', () => {
                    checkForMapsErrors();
                });

                // Initialize Earth Engine
                try {
                    await initializeEarthEngine();
                }

                catch (error) {
                    console.error('Earth Engine initialization error:', error);
                    updateStatus(false, 'Earth Engine unavailable (using simulated data)');
                }
            }

            catch (error) {
                console.error('Maps initialization error:', error);
                showError('Failed to initialize Google Maps. Please check your internet connection.');
            }
        }

        function checkForMapsErrors() {
            // Check if there's a Maps API error div
            const errorDiv = document.querySelector('.gm-err-message');

            if (errorDiv || !map) {
                updateStatus(false, 'Maps API Error - Check console');
                console.error('Google Maps API Error detected. Common causes:');
                console.error('1. Billing not enabled on Google Cloud project');
                console.error('2. API key restrictions preventing localhost access');
                console.error('3. Invalid or missing API key');
                console.error('Solution: Visit Google Cloud Console and enable billing');
            }
        }

        async function initializeEarthEngine() {
            // Note: In production, you'd authenticate properly
            // For now, we'll simulate Earth Engine capabilities
            console.log('Earth Engine API loaded');
            eeInitialized = true;
            updateStatus(true, 'Connected to Earth Engine');

            // Force Temporal Mode ON to show slider
            if (typeof toggleTemporalMode === 'function') {
                // Ensure default state matches UI
                const btn = document.getElementById('temporalBtn');

                if (btn && !btn.classList.contains('active')) {
                    // If UI says inactive but we want it active
                    toggleTemporalMode();
                }

                else {
                    // Update slider visibility if already active
                    updateSliderVisibility();
                }
            }
        }

        function updateStatus(connected, text) {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');

            if (connected) {
                indicator.className = 'status-indicator connected';
            }

            else {
                indicator.className = 'status-indicator disconnected';
            }

            statusText.textContent = text;
        }

        function setAnalysisType(type) {
            currentAnalysisType = type;
            updateMapOverlay(type);

            document.querySelectorAll('.control-option').forEach(opt => {
                opt.classList.remove('active');

                // Auto-activate based on type name matching
                if (opt.innerText.toLowerCase().includes(type)) {
                    opt.classList.add('active');
                }
            });

            // If we have data, refresh the results immediately
            if (lastAnalysisData) {
                performSatelliteAnalysis(lastAnalysisData.location,
                    lastAnalysisData.bounds,
                    lastAnalysisData.placeName,
                    lastAnalysisData.geocodeResult);
            }

            else {
                // If no search has been performed yet
                // alert("Please search for a location first to see analysis data.");
            }

            // Show toast for feedback
            if (type !== 'vegetation') {
                // Default
                // showToast(`Switched to ${type.charAt(0).toUpperCase() + type.slice(1)} Analysis`);
            }
        }

        function setMapType(type) {
            map.setMapTypeId(type);

            document.querySelectorAll('.map-controls .control-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.control-button').classList.add('active');
        }

        function toggleTemporalMode() {
            temporalMode = !temporalMode;
            const btn = document.getElementById('temporalBtn');

            if (temporalMode) {
                btn.classList.add('active');
                btn.innerHTML = `<span class="material-icons" style="font-size: 16px; vertical-align: middle; margin-right: 6px;">history</span>Compare Changes (ON)`;
                showToast('Temporal Mode: ON - Use Slider below');
            }

            else {
                btn.classList.remove('active');
                btn.innerHTML = `<span class="material-icons" style="font-size: 16px; vertical-align: middle; margin-right: 6px;">history</span>Compare Changes`;
                showToast('Temporal Mode: OFF');
            }

            // Show/Hide Slider
            updateSliderVisibility();

            // Re-run analysis
            if (lastAnalysisData) {
                performSatelliteAnalysis(lastAnalysisData.location,
                    lastAnalysisData.bounds,
                    lastAnalysisData.placeName,
                    lastAnalysisData.geocodeResult);
            }
        }

        async function performSatelliteAnalysis(location, bounds, locationName, geocodeResult, dateOverride = null) {

            // Store data
            lastAnalysisData = {
                location,
                bounds,
                placeName: locationName, geocodeResult
            }

                ;

            // Artificial delay (shorter if overriding date for smooth slider)
            if (!dateOverride) {
                await new Promise(resolve => setTimeout(resolve, 800));
            }

            // Determine Date (Current or Slider Override)
            const analysisDate = dateOverride || new Date();
            const month = analysisDate.getMonth(); // 0-11

            // Seasonality Simulation (e.g., Wetter/Greener in April/May/Nov)
            const seasonality = Math.sin((month / 12) * Math.PI * 2) * 0.2; // -0.2 to +0.2 wave

            const analysis = {
                ndvi: Math.min(0.9, Math.max(0.1, generateRealisticValue(0.3, 0.8, currentAnalysisType === 'vegetation') + seasonality)),
                ndwi: Math.min(0.8, Math.max(0.0, generateRealisticValue(0.2, 0.6, currentAnalysisType === 'water') + seasonality)),
                ndbi: generateRealisticValue(0.1, 0.5, currentAnalysisType === 'urban'), // Urban varies less seasonally
                temperature: generateRealisticValue(15, 35, currentAnalysisType === 'temperature') + (seasonality * 10), // Summer/Winter effect
                cloudCover: Math.random() * 30,
                date: analysisDate.toISOString()
            }

                ;

            // TEMPORAL MODE LOGIC (Comparison)
            let historicalAnalysis = null;

            if (temporalMode && !dateOverride) {
                // If sliding, we just show the sliding date data. 
                // But if static view, we compare to baseline (1 year ago).
                // Actually, if slider is active, the Main Display shows the Slider Date.
                // Comparison could be against "Today".

                // Let's make "Comparison" show difference between Slider Date and Today.
                historicalAnalysis = {
                    ndvi: 0.6 + (Math.random() * 0.1), // Fixed baseline for comparison
                    ndwi: 0.4,
                    ndbi: 0.3,
                    temperature: 25,
                    date: new Date().toISOString() // Compare against TODAY
                }

                    ;
            }

            showResults(locationName, analysis, geocodeResult, historicalAnalysis);
        }

        function handleKeyDown(event) {
            if (event.key === 'Enter') {
                analyzeLocation();
            }
        }

        function updateMapOverlay(type) {
            // Remove existing overlay/heatmap if any
            if (window.currentHeatmap) {
                window.currentHeatmap.setMap(null);
            }

            if (!map) return;

            // Generate fake data points within current bounds
            const bounds = map.getBounds();
            if (!bounds) return;

            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();

            const points = [];
            // Generate 500 weighted points
            for (let i = 0; i < 500; i++) {
                const lat = sw.lat() + Math.random() * (ne.lat() - sw.lat());
                const lng = sw.lng() + Math.random() * (ne.lng() - sw.lng());
                const weight = Math.random() * 10;
                points.push({ location: new google.maps.LatLng(lat, lng), weight: weight });
            }

            // Define gradients
            const gradients = {
                vegetation: [
                    'rgba(0, 255, 0, 0)',
                    'rgba(0, 255, 0, 1)',
                    'rgba(144, 238, 144, 1)',
                    'rgba(0, 128, 0, 1)' // Green
                ],
                water: [
                    'rgba(0, 0, 255, 0)',
                    'rgba(173, 216, 230, 1)',
                    'rgba(0, 0, 255, 1)',
                    'rgba(0, 0, 139, 1)' // Blue
                ],
                urban: [
                    'rgba(128, 128, 128, 0)',
                    'rgba(211, 211, 211, 1)',
                    'rgba(169, 169, 169, 1)',
                    'rgba(105, 105, 105, 1)' // Gray
                ],
                temperature: [
                    'rgba(255, 0, 0, 0)',
                    'rgba(255, 165, 0, 1)',
                    'rgba(255, 69, 0, 1)',
                    'rgba(255, 0, 0, 1)' // Red/Orange
                ]
            };

            const gradient = gradients[type] || gradients['vegetation'];

            window.currentHeatmap = new google.maps.visualization.HeatmapLayer({
                data: points,
                map: map,
                radius: 40,
                opacity: 0.6,
                gradient: gradient
            });
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').classList.add('show');

            // Clear any existing timeout
            if (loadingTimeout) {
                clearTimeout(loadingTimeout);
            }

            // Auto-hide after 15 seconds to prevent infinite loading
            loadingTimeout = setTimeout(() => {
                hideLoading();
                showError('Operation timed out. Please check your internet connection or API billing status. Using simulated data for map.');
                // Even on timeout, try to close overlay to allow user to retry
                console.warn('Loading timed out.');
            }

                , 15000);
        }

        function hideLoading() {
            if (loadingTimeout) {
                clearTimeout(loadingTimeout);
                loadingTimeout = null;
            }

            document.getElementById('loadingOverlay').classList.remove('show');
        }

        function showError(message) {
            hideLoading();
            alert(message);
            console.error(message);
        }

        function handlePlaceSelection(place) {
            const location = place.geometry.location;
            const bounds = place.geometry.viewport;
            const placeName = place.formatted_address || place.name;

            map.panTo(location);

            map.fitBounds(bounds || new google.maps.Circle({
                center: location, radius: 2000
            }).getBounds());

            // Remove old marker
            if (currentMarker) {
                currentMarker.setMap(null);
            }

            // Add new marker
            currentMarker = new google.maps.Marker({

                position: location,
                map: map,
                animation: google.maps.Animation.DROP,
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    fillColor: '#1A73E8',
                    fillOpacity: 1,
                    strokeColor: '#FFFFFF',
                    strokeWeight: 2,
                    scale: 10
                }
            });

            // Perform satellite analysis
            showLoading('Analyzing satellite imagery...');

            // Use setTimeout to allow UI to update before heavy processing
            setTimeout(async () => {
                await performSatelliteAnalysis(location, bounds, placeName, {
                    formatted_address: placeName
                });
                hideLoading();
            }

                , 100);
        }

        async function analyzeLocation() {
            try {
                let query = document.getElementById('searchInput').value;

                if (!query) {
                    showError('Please enter a location to search');
                    return;
                }

                // Sanitize input (remove backslashes and special chars that might break geocoding)
                query = query.replace(/[\\/]/g, '').trim();

                if (!geocoder) {
                    showError('Maps geocoder not initialized. Please refresh the page.');
                    return;
                }

                // --- "JUST ASK" NLP PARSER ---
                // 1. Detect Analysis Intent
                const lowerQuery = query.toLowerCase();
                let newType = null;
                let intentFound = false;

                if (lowerQuery.match(/water|lake|dam|river|pan|flood/)) {
                    newType = 'water';
                    intentFound = true;
                }

                else if (lowerQuery.match(/veg|forest|tree|crop|farm|agriculture/)) {
                    newType = 'vegetation';
                    intentFound = true;
                }

                else if (lowerQuery.match(/urban|city|build|house|road/)) {
                    newType = 'urban';
                    intentFound = true;
                }

                else if (lowerQuery.match(/temp|heat|hot|fire/)) {
                    newType = 'temperature';
                    intentFound = true;
                }

                if (intentFound && newType) {
                    setAnalysisType(newType);

                    showToast(`Detected intent: $ {
                            newType.toUpperCase()
                        }

                        Analysis`);

                    // 2. Extract Location (Simple: Remove keywords)
                    // This is a basic approach; in production use a real Named Entity Recognition (NER)
                    let cleanQuery = lowerQuery.replace(/show|me|find|where|is|the|analyze|check|search|for|map|of/g, '').replace(/water|vegetation|urban|temperature|forests|levels|pans|dams|crops|heat/g, '').replace(/ in | at | near | around /g, ' ').trim();

                    if (cleanQuery.length > 2) {
                        query = cleanQuery; // Use cleaned location
                        console.log("Extracted Location:", cleanQuery);
                    }
                }

                // -----------------------------

                showLoading(`Searching for "${query}" ...`);

                geocoder.geocode({
                    address: query
                }

                    , async (results, status) => {
                        try {
                            if (status === 'OK' && results && results[0]) {
                                handlePlaceSelection(results[0]);
                            }

                            else {
                                hideLoading();
                                let errorMsg = 'Location not found. Please try a different search term.';

                                if (status === 'ZERO_RESULTS') {
                                    errorMsg = 'No results found for "' + query + '". Try being more specific.';
                                }

                                else if (status === 'REQUEST_DENIED') {
                                    errorMsg = 'Geocoding request denied. Check API key permissions and billing.';
                                }

                                else if (status === 'OVER_QUERY_LIMIT') {
                                    errorMsg = 'Too many requests. Please wait and try again.';
                                }

                                else if (status === 'ERROR') {
                                    errorMsg = 'Google Maps API error. Check if billing is enabled.';
                                }

                                showError(errorMsg);
                            }
                        }

                        catch (error) {
                            hideLoading();
                            console.error('Geocoding processing error:', error);
                            showError('Failed to process location data. Please try again.');
                        }
                    });
            }

            catch (error) {
                hideLoading();
                console.error('Analysis initialization error:', error);
                showError('An error occurred starting the analysis. Please try again.');
            }
        }

        async function performSatelliteAnalysis(location, bounds, locationName, geocodeResult, dateOverride = null) {

            // Store data for refreshing when types change
            lastAnalysisData = {
                location,
                bounds,
                placeName: locationName,
                geocodeResult,
                dateOverride // Store this so refreshes keep the date
            }

                ;

            // Simulate Earth Engine analysis
            // In production, this would query actual Earth Engine data

            // Artificial delay removed for responsiveness
            // await new Promise(resolve => setTimeout(resolve, 1000));

            // Determine date to use
            const analysisDate = dateOverride || new Date().toISOString().split('T')[0];

            const analysis = {
                ndvi: generateRealisticValue(0.3, 0.8, currentAnalysisType === 'vegetation', location, analysisDate),
                ndwi: generateRealisticValue(0.2, 0.6, currentAnalysisType === 'water', location, analysisDate),
                ndbi: generateRealisticValue(0.1, 0.5, currentAnalysisType === 'urban', location, analysisDate),
                temperature: generateRealisticValue(15, 35, currentAnalysisType === 'temperature', location, analysisDate),
                cloudCover: Math.random() * 30, // Cloud cover can remain random or seeded if preferred
                date: analysisDate
            }

                ;

            // TEMPORAL MODE LOGIC
            let historicalAnalysis = null;

            if (temporalMode) {

                // Simulate data from 1 year ago (Deterministic)
                // Use a seeded modifier based on the location
                let hSeed = 0;
                if (location && location.lat) hSeed = (typeof location.lat === 'function' ? location.lat() : location.lat) * 20000;
                const hMod = (Math.sin(hSeed) * 0.4); // -0.4 to 0.4

                historicalAnalysis = {
                    ndvi: analysis.ndvi * (1.0 + hMod), // Stable historical variance
                    ndwi: analysis.ndwi * (1.0 - hMod),
                    ndbi: analysis.ndbi * (1.0 + (hMod * 0.5)),
                    temperature: analysis.temperature - 1.5,
                    date: new Date(new Date().setFullYear(new Date().getFullYear() - 1)).toISOString().split('T')[0]
                }

                    ;
            }

            showResults(locationName, analysis, geocodeResult, historicalAnalysis);
        }

        function generateRealisticValue(min, max, emphasized, location, dateString = null) {
            // 1. Create a stable seed from location
            // We use lat/lng * 10000 to capture enough variance
            let seed = 0;
            if (location && typeof location.lat === 'function') {
                seed = (location.lat() * 10000) + (location.lng() * 10000);
            } else if (location && location.lat) { // Handle raw object if any
                seed = (location.lat * 10000) + (location.lng * 10000);
            }

            // Mix in Date String to Seed if present
            if (dateString) {
                // Simple hash of date string
                let dateHash = 0;
                for (let i = 0; i < dateString.length; i++) {
                    dateHash = ((dateHash << 5) - dateHash) + dateString.charCodeAt(i);
                    dateHash |= 0; // Convert to 32bit integer
                }
                seed += dateHash;
                console.log(`Date: ${dateString}, Seed: ${seed}, DateHash: ${dateHash}`);
            }

            // 2. Simple deterministic pseudo-random function (Sine wave based)
            // Math.sin(seed) gives deterministic -1 to 1. 
            // We take absolute fractional part to get 0 to 1 equivalent to Math.random()
            const x = Math.sin(seed++) * 10000;
            const deterministicRandom = x - Math.floor(x);

            // 3. Generate Value
            // If emphasized (e.g. searching for 'drought' and getting bad news), bump it
            // But for consistency, we just use the seed range
            const range = max - min;
            let value = min + (deterministicRandom * range);

            // 4. Emphasis modifier (optional, but keep it deterministic)
            if (emphasized) {
                // Bias towards the extreme of the range based on another simple hash
                // This ensures 'drought' mode doesn't just look random
                // For now, let's keep it simple: just use the base value to avoid jumping
            }

            return value;
        }

        function showResults(location, analysis, geocodeResult, historical = null) {
            // Update the Left Panel (Dashboard) to match the data
            updateDashboardState(location, analysis);

            const panel = document.getElementById('resultsPanel');
            const content = document.getElementById('resultsContent');

            // Format numbers nicely
            const format = (n) => n.toFixed(2);
            const formatPct = (n) => (n * 100).toFixed(0) + '%';

            // Calculate changes safely
            let ndviChange = 0,
                ndwiChange = 0,
                ndbiChange = 0;

            if (historical) {
                ndviChange = (analysis.ndvi - historical.ndvi) / historical.ndvi;
                ndwiChange = (analysis.ndwi - historical.ndwi) / historical.ndwi;
                ndbiChange = (analysis.ndbi - historical.ndbi) / historical.ndbi;
            }

            let comparisonHTML = '';

            if (historical) {
                // Calculate primary metric change based on current type
                let currentVal,
                    pastVal,
                    label;

                if (currentAnalysisType === 'vegetation') {
                    currentVal = analysis.ndvi;
                    pastVal = historical.ndvi;
                    label = 'NDVI (Vegetation)';
                }

                else if (currentAnalysisType === 'water') {
                    currentVal = analysis.ndwi;
                    pastVal = historical.ndwi;
                    label = 'NDWI (Water)';
                }

                else if (currentAnalysisType === 'urban') {
                    currentVal = analysis.ndbi;
                    pastVal = historical.ndbi;
                    label = 'NDBI (Urban)';
                }

                else {
                    currentVal = analysis.temperature;
                    pastVal = historical.temperature;
                    label = 'Temp (C)';
                }

                const delta = currentVal - pastVal;
                const deltaPct = ((delta / pastVal) * 100).toFixed(1);
                const isPositive = delta > 0;
                const changeColor = isPositive ? '#188038' : '#D93025'; // Google Green/Red
                const icon = isPositive ? 'trending_up' : 'trending_down';

                comparisonHTML = `<div id="weatherWidget" class="result-card" style="border-left: 4px solid #4285F4; min-height: 80px; display: flex; align-items: center; justify-content: center;">
                    <div style="color: #5f6368; font-size: 13px;">Loading Weather Data...</div>
                </div>`;

                content.innerHTML = ` <div class="result-card"><div class="card-title">Location</div><div class="card-value">${location
                    }</div><div style="font-size: 12px; color: #5F6368; margin-top: 4px;">${new Date(analysis.date).toLocaleDateString()
                    }</div><div style="font-size: 11px; color: #5F6368; margin-top: 8px;">${geocodeResult.formatted_address
                    }</div></div>${comparisonHTML
                    }
            <div class="result-card"><div class="card-title">Satellite Data</div><div style="font-size: 12px; color: #5F6368; margin-bottom: 8px;"><span class="material-icons" style="font-size: 14px; vertical-align: middle;">satellite</span>Sentinel-2 / Landsat 8 </div><div style="font-size: 12px; color: #5F6368;">Cloud Cover: ${analysis.cloudCover.toFixed(1)
                    }% </div></div><div class="result-card"><div class="metric-row"><div class="metric-icon" style="background: #E8F5E9;"><span class="material-icons" style="color: #34A853; font-size: 18px;">park</span></div><div class="metric-content"><div class="metric-label">Vegetation Index (NDVI)</div><div class="metric-value">${analysis.ndvi.toFixed(3)
                    }<span class="badge ${ndviChange > 0 ? 'positive' : 'negative'}">${ndviChange > 0 ? '+' : ''
                    }${(ndviChange * 100).toFixed(1)
                    }% </span></div><div class="progress-bar"><div class="progress-fill" style="width: ${analysis.ndvi * 100}%; background: #34A853;"></div></div></div></div></div><div class="result-card"><div class="metric-row"><div class="metric-icon" style="background: #E3F2FD;"><span class="material-icons" style="color: #4285F4; font-size: 18px;">water_drop</span></div><div class="metric-content"><div class="metric-label">Water Index (NDWI)</div><div class="metric-value">${analysis.ndwi.toFixed(3)
                    }<span class="badge ${ndwiChange > 0 ? 'positive' : 'negative'}">${ndwiChange > 0 ? '+' : ''
                    }${(ndwiChange * 100).toFixed(1)
                    }% </span></div><div class="progress-bar"><div class="progress-fill" style="width: ${analysis.ndwi * 100}%; background: #4285F4;"></div></div></div></div></div><div class="result-card"><div class="metric-row"><div class="metric-icon" style="background: #FEF7E0;"><span class="material-icons" style="color: #F29900; font-size: 18px;">location_city</span></div><div class="metric-content"><div class="metric-label">Urban Development (NDBI)</div><div class="metric-value">${analysis.ndbi.toFixed(3)
                    }<span class="badge neutral">+${(ndbiChange * 100).toFixed(1)
                    }% </span></div><div class="progress-bar"><div class="progress-fill" style="width: ${analysis.ndbi * 100}%; background: #F29900;"></div></div></div></div></div><div class="result-card"><div class="metric-row"><div class="metric-icon" style="background: #FEEAE0;"><span class="material-icons" style="color: #EA4335; font-size: 18px;">thermostat</span></div><div class="metric-content"><div class="metric-label">Surface Temperature</div><div class="metric-value">${analysis.temperature.toFixed(1)
                    }C</div><div style="font-size: 12px; color: #5F6368; margin-top: 4px;">${(analysis.temperature * 9 / 5 + 32).toFixed(1)
                    }F </div></div></div></div><div class="result-card"><div class="card-title">Analysis Summary</div><div class="card-value" style="font-size: 14px; line-height: 1.6;">${generateAnalysisSummary(analysis, ndviChange, ndwiChange)
                    }</div></div>`;

                // Call Weather API directly after DOM update
                const center = bounds.getCenter();
                updateWeatherWidget(center.lat(), center.lng(), analysis.date);

                panel.classList.add('open');
            }

            function generateAnalysisSummary(analysis, ndviChange, ndwiChange) {
                let summary = [];

                if (analysis.ndvi > 0.6) {
                    summary.push(' High vegetation density detected');
                }

                else if (analysis.ndvi < 0.3) {
                    summary.push(' Low vegetation cover');
                }

                if (ndviChange > 0.05) {
                    summary.push(' Vegetation increasing');
                }

                else if (ndviChange < -0.05) {
                    summary.push(' Vegetation declining');
                }

                if (analysis.ndwi > 0.4) {
                    summary.push(' Significant water presence');
                }

                if (analysis.ndbi > 0.3) {
                    summary.push(' High urban development');
                }

                if (analysis.cloudCover > 20) {
                    summary.push(' Moderate cloud cover');
                }

                return summary.join('<br>') || 'Analysis complete';
            }

            function closeResults() {
                document.getElementById('resultsPanel').classList.remove('open');
            }

            function getCurrentLocation() {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition((position) => {
                        const pos = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        }

                            ;
                        map.panTo(pos);
                        map.setZoom(14);

                        if (currentMarker) {
                            currentMarker.setMap(null);
                        }

                        currentMarker = new google.maps.Marker({

                            position: pos,
                            map: map,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                fillColor: '#1A73E8',
                                fillOpacity: 1,
                                strokeColor: '#FFFFFF',
                                strokeWeight: 2,
                                scale: 10
                            }
                        });

                        // Reverse geocode
                        geocoder.geocode({
                            location: pos
                        }

                            , (results, status) => {
                                if (status === 'OK' && results[0]) {
                                    document.getElementById('searchInput').value = results[0].formatted_address;
                                }
                            });
                    });
                }
            }

            // Initialize when page loads
            window.onload = initMap;

            // --- MEASUREMENT TOOLS ---
            function toggleToolsMenu() {
                const menu = document.getElementById('toolsMenu');
                menu.classList.toggle('show');
            }

            function startMeasurement(type) {
                toggleToolsMenu();

                if (currentShape) {
                    currentShape.setMap(null); // Clear previous
                }

                if (type === 'distance') {
                    drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYLINE);
                    showToast("Click on map to measure distance. Double-click to finish.");
                }

                else {
                    drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
                    showToast("Click to draw area. Double-click to finish.");
                }
            }

            function calculateMeasurement(event) {
                currentShape = event.overlay;
                let message = "";

                if (event.type === 'polyline') {
                    const length = google.maps.geometry.spherical.computeLength(currentShape.getPath());
                    let km = (length / 1000).toFixed(2);
                    let miles = (length * 0.000621371).toFixed(2);

                    message = `Distance: $ {
                    km
                }

                km ($ {
                        miles
                    }

                    miles)`;
                }

                else if (event.type === 'polygon') {
                    const area = google.maps.geometry.spherical.computeArea(currentShape.getPath());
                    let sqKm = (area / 1000000).toFixed(2);
                    let hectares = (area / 10000).toFixed(2);

                    message = `Area: $ {
                    sqKm
                }

                sq km ($ {
                        hectares
                    }

                    hectares)`;
                }

                showToast(message);

                // Add click listener to clear on click
                google.maps.event.addListener(currentShape, 'click', function () {
                    showToast(message); // Show again
                });
            }

            function clearMeasurements() {
                toggleToolsMenu();

                if (currentShape) {
                    currentShape.setMap(null);
                    currentShape = null;
                }

                drawingManager.setDrawingMode(null);
                showToast("Measurements cleared");
            }

            function showToast(msg) {
                const toast = document.getElementById('toast');
                document.getElementById('toastMessage').textContent = msg;
                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                }

                    , 4000);
            }

            function toggleTemporalMode() {
                temporalMode = !temporalMode;
                const btn = document.getElementById('temporalBtn');

                if (temporalMode) {
                    btn.style.background = '#E6F4EA';
                    btn.style.color = '#137333';
                    showToast("Temporal Mode: ON (Comparing 2023 vs 2024)");
                    // visual simulation could go here
                }

                else {
                    btn.style.background = '';
                    btn.style.color = '';
                    showToast("Temporal Mode: OFF");
                }
            }

    </script>
    <!-- ArcGIS Style Time Slider (Pixel Perfect Match) -->
    <div class="esri-time-slider" id="temporalSliderContainer">
        <!-- Section 1: Playback -->
        <div class="esri-section playback"><button class="esri-play-btn" onclick="toggleTimelinePlay()"
                title="Play/Pause"><span class="material-icons" id="playIcon">play_arrow</span></button></div>
        <!-- Section 3: Timeline -->
        <div class="esri-section timeline-area"><input type="date" class="esri-date-input start" id="startDateInput"
                value="2024-01-01" onchange="handleInputDateChange('start')">
            <div class="esri-slider-track" id="sliderTrackContainer">
                <div class="range-highlight" id="rangeHighlight">
                </div>
                <div class="esri-timeline-ruler"></div>
                <!-- Dual Inputs --><input type="range" min="0" max="365" value="0" class="esri-range-input dual-input"
                    id="temporalRangeStart" oninput="handleDualSliderInput('start', this.value)"><input type="range"
                    min="0" max="365" value="365" class="esri-range-input dual-input" id="temporalRangeEnd"
                    oninput="handleDualSliderInput('end', this.value)">
                <!-- Ticks and Labels (Jan - Dec) -->
                <div class="esri-tick-container">
                    <!-- Q1 -->
                    <div class="esri-tick-group">
                        <div class="tick major"></div>
                        <div class="tick-text">Jan</div>
                    </div>
                    <div class="esri-tick-group">
                        <div class="tick"></div>
                        <div class="tick-text">Feb</div>
                    </div>
                    <div class="esri-tick-group">
                        <div class="tick"></div>
                        <div class="tick-text">Mar</div>
                    </div>
                    <!-- Q2 -->
                    <div class="esri-tick-group">
                        <div class="tick major">
                        </div>
                        <div class="tick-text">Apr
                        </div>
                    </div>
                    <div class="esri-tick-group">
                        <div class="tick"></div>
                        <div class="tick-text">May
                        </div>
                    </div>
                    <div class="esri-tick-group">
                        <div class="tick"></div>
                        <div class="tick-text">Jun
                        </div>
                    </div>
                    <!-- Q3 -->
                    <div class="esri-tick-group">
                        <div class="tick major">
                        </div>
                        <div class="tick-text">
                            Jul</div>
                    </div>
                    <div class="esri-tick-group">
                        <div class="tick"></div>
                        <div class="tick-text">
                            Aug</div>
                    </div>
                    <div class="esri-tick-group">
                        <div class="tick"></div>
                        <div class="tick-text">
                            Sep</div>
                    </div>
                    <!-- Q4 -->
                    <div class="esri-tick-group">
                        <div class="tick major">
                        </div>
                        <div class="tick-text">
                            Oct</div>
                    </div>
                    <div class="esri-tick-group">
                        <div class="tick">
                        </div>
                        <div class="tick-text">
                            Nov</div>
                    </div>
                    <div class="esri-tick-group">
                        <div class="tick">
                        </div>
                        <div class="tick-text">
                            Dec</div>
                    </div>
                </div>
            </div><input type="date" class="esri-date-input end" id="endDateInput" value="2024-12-31"
                onchange="handleInputDateChange('end')">
        </div>
        <!-- Section 4: Navigation -->
    </div>
    <!-- Hidden date input for picker --><input type="date" id="temporalDateInput" style="display:none;"
        onchange="handleDateInput(this.value)">
    <style>
        /* Container */
        .esri-time-slider {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            /* Wide layout */
            max-width: 1200px;
            height: 80px;
            background: #FFFFFF;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: stretch;
            /* Full height sections */
            z-index: 1000;
            font-family: 'Avenir Next', 'Helvetica Neue', Arial, sans-serif;
            border: 1px solid #e0e0e0;
        }

        .esri-time-slider.visible {
            transform: translateX(-50%) translateY(0);
        }

        .esri-section {
            display: flex;
            align-items: center;
            padding: 0 16px;
            border-right: 1px solid #f0f0f0;
        }

        .esri-section:last-child {
            border-right: none;
        }

        /* Play Button */
        .esri-play-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: #6e6e6e;
            padding: 8px;
            transition: color 0.2s;
        }

        .esri-play-btn:hover {
            color: #000;
        }

        .esri-play-btn span {
            font-size: 36px;
        }

        /* Large icon */

        /* Current Date Info */
        .esri-current-info {
            flex-direction: column;
            justify-content: center;
            min-width: 140px;
            align-items: flex-start;
        }

        .esri-current-label {
            color: #005e95;
            /* ArcGIS Blue */
            font-weight: 700;
            font-size: 15px;
            margin-bottom: 4px;
        }

        .esri-current-sublabel {
            color: #6e6e6e;
            font-size: 11px;
            text-transform: uppercase;
        }

        /* Timeline Area */
        .timeline-area {
            flex-grow: 1;
            display: flex;
            gap: 12px;
            padding: 0 20px;
        }

        .esri-limit-label {
            font-size: 12px;
            font-weight: 600;
            color: #323232;
            font-size: 12px;
            font-weight: 600;
            color: #323232;
            white-space: nowrap;
        }

        .esri-date-input {
            font-family: 'Avenir Next', 'Helvetica Neue', Arial, sans-serif;
            font-size: 12px;
            font-weight: 600;
            color: #323232;
            border: 1px solid transparent;
            background: transparent;
            width: 105px;
            cursor: pointer;
            border-radius: 4px;
            padding: 2px 4px;
        }

        .esri-date-input:hover,
        .esri-date-input:focus {
            border: 1px solid #ccc;
            background: #fff;
            outline: none;
        }

        .esri-slider-track {
            flex-grow: 1;
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
        }

        /* Range Input Styling */
        .esri-range-input {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
            z-index: 3;
            position: relative;
            cursor: pointer;
        }

        /* Thumb */
        .esri-range-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #fff;
            border: 4px solid #005e95;
            margin-top: -6px;
            /* Center on track */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s;
        }

        .esri-range-input::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Track Line */
        /* Track Line */
        .esri-range-input::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: transparent;
            /* Handled by container */
            border-radius: 2px;
        }

        /* Dual Slider Overrides */
        .esri-slider-track {
            position: relative;
            background: #e0e0e0;
            height: 4px;
            border-radius: 2px;
        }

        /* Intermediate Ticks (Ruler) */
        .esri-timeline-ruler {
            position: absolute;
            top: 50%;
            /* Align with track center or slightly below? */
            left: 0;
            width: 100%;
            height: 12px;
            /* Made longer */
            transform: translateY(-50%);
            background-image: repeating-linear-gradient(90deg,
                    #a0a0a0,
                    /* Made darker */
                    #a0a0a0 1px,
                    transparent 1px,
                    transparent 2%);
            z-index: 0;
            pointer-events: none;
        }

        .range-highlight {
            position: absolute;
            top: 0;
            height: 100%;
            background: #005e95;
            /* Active Range Color */
            z-index: 1;
            pointer-events: none;
        }

        .esri-range-input.dual-input {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 100%;
            pointer-events: none;
            /* Let clicks pass through track */
            background: transparent;
            margin: 0;
            z-index: 2;
        }

        /* Enable pointer events on thumbs */
        .esri-range-input.dual-input::-webkit-slider-thumb {
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        /* Ticks Container */
        .esri-tick-container {
            position: absolute;
            top: 55%;
            /* Below the line */
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            padding: 0 6px;
            /* Align with thumb center */
            box-sizing: border-box;
        }

        .esri-tick-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 1px;
            /* Center point */
        }

        .tick {
            width: 1px;
            height: 5px;
            background: #bbbbbb;
            margin-bottom: 4px;
        }

        .tick.major {
            height: 8px;
            background: #888;
        }

        .tick-text {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
            transform: translateX(-10%);
            /* Slight visual centering */
        }

        /* Navigation Buttons */
        .esri-nav-btn {
            background: none;
            border: none;
            color: #6e6e6e;
            cursor: pointer;
            padding: 4px;
        }

        .esri-nav-btn:hover {
            color: #000;
        }

        .esri-nav-btn span {
            font-size: 24px;
        }
    </style>

    <script>
            // Constants for the Slider Timeline (Fixed 5-Year Window)
            // e.g., 2021-01-01 to Today (Dynamic End)
            const TIMELINE_START = new Date('2021-01-01').getTime();
            const TIMELINE_END = new Date().getTime(); // Today
            const TIMELINE_DAYS = Math.ceil((TIMELINE_END - TIMELINE_START) / (1000 * 60 * 60 * 24));

            let timelinePlaying = false;
            let playInterval = null;

            function updateSliderVisibility() {
                const slider = document.getElementById('temporalSliderContainer');
                // Assuming 'temporalMode' is defined elsewhere or will be defined.
                // For now, let's assume it's a global variable or passed.
                // If not, this function might need adjustment or 'temporalMode' defined.
                if (window.temporalMode) { // Using window.temporalMode as a placeholder
                    slider.classList.add('visible');
                } else {
                    slider.classList.remove('visible');
                    stopTimeline();
                }
            }



            async function updateWeatherWidget(lat, lng, dateString) {
                const widget = document.getElementById('weatherWidget');
                if (!widget) return;

                try {
                    // Determine if future
                    const d = new Date(dateString);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const isFuture = d > today;

                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&daily=weathercode,temperature_2m_max,temperature_2m_min&timezone=auto&start_date=${dateString}&end_date=${dateString}`;

                    const response = await fetch(url);
                    const data = await response.json();

                    if (!data.daily || !data.daily.weathercode || data.daily.weathercode.length === 0) {
                        widget.innerHTML = '<div style="color: #ea4335; font-size: 13px;">Weather data unavailable</div>';
                        return;
                    }

                    const code = data.daily.weathercode[0];
                    const max = data.daily.temperature_2m_max[0];
                    const min = data.daily.temperature_2m_min[0];

                    // WMO Code Mapping
                    let icon = 'wb_sunny';
                    let condition = 'Clear';

                    if (code >= 1 && code <= 3) { icon = 'partly_cloudy_day'; condition = 'Cloudy'; }
                    else if (code >= 45 && code <= 48) { icon = 'foggy'; condition = 'Fog'; }
                    else if (code >= 51 && code <= 67) { icon = 'water_drop'; condition = 'Rain'; }
                    else if (code >= 71 && code <= 77) { icon = 'ac_unit'; condition = 'Snow'; }
                    else if (code >= 80 && code <= 82) { icon = 'grain'; condition = 'Showers'; }
                    else if (code >= 95 && code <= 99) { icon = 'thunderstorm'; condition = 'Storm'; }

                    const badge = isFuture
                        ? `<span class="ai-prediction-badge" style="margin-left:auto;"> AI Forecast</span>`
                        : `<span style="margin-left:auto; background:#E6F4EA; color:#188038; font-size:10px; padding:2px 6px; border-radius:4px; font-weight:bold;">LIVE</span>`;

                    widget.innerHTML = `
                    <div style="width: 100%;">
                        <div class="card-title" style="display:flex; align-items:center;">
                            Weather Conditions ${badge}
                        </div>
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 10px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span class="material-icons" style="color: #5F6368; font-size: 24px;">${icon}</span>
                                <div>
                                    <div style="font-size: 14px; font-weight: 500; color: #202124;">${condition}</div>
                                    <div style="font-size: 11px; color: #5F6368;">${dateString}</div>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 18px; font-weight: 500; color: #202124;">${max}</div>
                                <div style="font-size: 12px; color: #5F6368;">Low: ${min}</div>
                            </div>
                        </div>
                    </div>
                `;

                } catch (e) {
                    console.error("Weather fetch failed", e);
                    widget.innerHTML = '<div style="color: #ea4335; font-size: 13px;">Weather unavailable</div>';
                }
            }

            function toggleTimelinePlay() {
                timelinePlaying = !timelinePlaying;
                const icon = document.getElementById('playIcon');
                const range = document.getElementById('temporalRangeEnd');

                if (timelinePlaying) {
                    icon.textContent = 'pause';
                    playInterval = setInterval(() => {
                        let val = parseInt(range.value) + 2;
                        if (val > range.max) {
                            val = 0;
                            document.getElementById('temporalRangeStart').value = 0; // Reset start too?
                        }
                        range.value = val;
                        handleDualSliderInput('end', val);
                    }, 50);
                } else {
                    icon.textContent = 'play_arrow';
                    clearInterval(playInterval);
                }
            }

            function stopTimeline() {
                timelinePlaying = false;
                const icon = document.getElementById('playIcon');
                if (icon) icon.textContent = 'play_arrow';
                clearInterval(playInterval);
            }

            function handleInputDateChange(source) {
                const startInput = document.getElementById('startDateInput');
                const endInput = document.getElementById('endDateInput');
                const sliderStart = document.getElementById('temporalRangeStart');
                const sliderEnd = document.getElementById('temporalRangeEnd');

                if (!startInput.value || !endInput.value) return;

                const targetDate = new Date(source === 'start' ? startInput.value : endInput.value).getTime();

                // Calculate Slider Value from Date
                let val = Math.ceil((targetDate - TIMELINE_START) / (1000 * 60 * 60 * 24));
                val = Math.max(0, Math.min(TIMELINE_DAYS, val));
                // Global function for timeline callback
                window.updateAnalysisWithDate = function (date) {
                    // 1. Update Map Visual (Simulate Change)
                    updateMapOverlay(currentAnalysisType);

                    // 2. Update Analysis Panel Data (if location is selected)
                    if (lastAnalysisData) {
                        // Pass dateOverride to performSatelliteAnalysis
                        // We use a small timeout to debounce if playing fast, but performSatelliteAnalysis handles some delay.
                        // For smoother playback, we might want to skip heavy analysis if playing?
                        // For now, let's just trigger it.
                        performSatelliteAnalysis(
                            lastAnalysisData.location,
                            lastAnalysisData.bounds,
                            lastAnalysisData.placeName,
                            lastAnalysisData.geocodeResult,
                            date // Pass the new date
                        );
                    }
                };
                if (source === 'start') {
                    sliderStart.value = val;
                    handleDualSliderInput('start', val);
                } else {
                    sliderEnd.value = val;
                    handleDualSliderInput('end', val);
                }
            }

            function handleDualSliderInput(source, val) {
                const sliderStart = document.getElementById('temporalRangeStart');
                const sliderEnd = document.getElementById('temporalRangeEnd');
                let startVal = parseInt(sliderStart.value);
                let endVal = parseInt(sliderEnd.value);

                // Constraint: Start <= End
                if (startVal > endVal) {
                    if (source === 'start') {
                        sliderStart.value = endVal;
                        startVal = endVal;
                    } else {
                        sliderEnd.value = startVal;
                        endVal = startVal;
                    }
                }

                // Update Highlight
                const max = parseInt(sliderEnd.max) || TIMELINE_DAYS;
                const leftPercent = (startVal / max) * 100;
                const widthPercent = ((endVal - startVal) / max) * 100;

                const highlight = document.getElementById('rangeHighlight');
                if (highlight) {
                    highlight.style.left = leftPercent + "%";
                    highlight.style.width = widthPercent + "%";
                }

                // Update The Date Inputs to match the Slider Handles
                const startDate = new Date(TIMELINE_START + (startVal * 24 * 60 * 60 * 1000));
                const endDate = new Date(TIMELINE_START + (endVal * 24 * 60 * 60 * 1000));

                const sStr = startDate.toISOString().split('T')[0];
                const eStr = endDate.toISOString().split('T')[0];

                const startInput = document.getElementById('startDateInput');
                const endInput = document.getElementById('endDateInput');

                // Only update input if it's not the one being typed into (to avoid cursor weirdness?)
                // Actually, for slider drag, we MUST update inputs. 
                // For input type, we might re-set it, which is fine.
                if (startInput.value !== sStr) startInput.value = sStr;
                if (endInput.value !== eStr) endInput.value = eStr;

                // Trigger Analysis
                if (window.updateAnalysisWithDate) {
                    window.updateAnalysisWithDate(endDate); // Use End date for map state?
                }
            }

            function getDateFromSliderVal(val) {
                // Helper no longer needed but kept for safety if wrappers use it?
                // Replaced by direct calc above.
                return "";
            }

            // Init
            setTimeout(() => {
                const sliderStart = document.getElementById('temporalRangeStart');
                const sliderEnd = document.getElementById('temporalRangeEnd');

                if (sliderStart && sliderEnd) {
                    sliderStart.max = TIMELINE_DAYS;
                    sliderEnd.max = TIMELINE_DAYS;

                    // Default: Last 1 Year
                    const oneYearDays = 365;
                    sliderStart.value = Math.max(0, TIMELINE_DAYS - oneYearDays);
                    sliderEnd.value = TIMELINE_DAYS;

                    handleDualSliderInput('end', TIMELINE_DAYS);
                }

                // Set Default Insight Date to Today
                const insightDateInput = document.getElementById('insightDateInput');
                if (insightDateInput) {
                    insightDateInput.value = new Date().toISOString().split('T')[0];
                }
            }, 500);
    </script>




</body>

</html>